DATA = [{"ffmpeg":"avcodec_receive_packet","goRep":[{"name":"goav/avcodec.CodecContext::ReceivePacket","doc":"\u003cp\u003e\nReceivePacket receives a packet as output from the decoder.\nC-Function: avcodec_receive_packet\n\u003c/p\u003e\n"}]},{"ffmpeg":"flags","goRep":[{"name":"goav/avcodec.CodecContext::Flags","doc":"\u003cp\u003e\nFlags returns the flags AV_CODEC_FLAG_*.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: flags\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetFlags","doc":"\u003cp\u003e\nSetFlags set the flags AV_CODEC_FLAG_*.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: flags\n\u003c/p\u003e\n"}]},{"ffmpeg":"avcodec_open2","goRep":[{"name":"goav/avcodec.CodecContext::Open","doc":"\u003cp\u003e\nOpen initializes the CodecContext to use the given Codec.\nC-Function: avcodec_open2\n\u003c/p\u003e\n"}]},{"ffmpeg":"avcodec_encode_subtitle","goRep":[{"name":"goav/avcodec.CodecContext::EncodeSubtitle","doc":"\u003cp\u003e\nEncodeSubtitle encodes a subtitle message.\nC-Function: avcodec_encode_subtitle\n\u003c/p\u003e\n"}]},{"ffmpeg":"avcodec_fill_audio_frame","goRep":[{"name":"goav/avcodec.Frame::FillAudioFrame","doc":"\u003cp\u003e\nFillAudioFrame fills the Frame audio data and linesize pointers.\n\u003c/p\u003e\n\u003cp\u003e\nC-Function: avcodec_fill_audio_frame\n\u003c/p\u003e\n"}]},{"ffmpeg":"width","goRep":[{"name":"goav/avcodec.CodecContext::SetWidth","doc":"\u003cp\u003e\nSetWidth sets the raw image width.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: width\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::Width","doc":"\u003cp\u003e\nWidth returns the raw image width.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: width\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecParameters::Width","doc":"\u003cp\u003e\nWidth returns the width of the video frame in pixels.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: width\n\u003c/p\u003e\n"}]},{"ffmpeg":"profile","goRep":[{"name":"goav/avcodec.CodecParameters::Profile","doc":"\u003cp\u003e\nProfile returns the codec-specific bitstream restrictions that the stream conforms to.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: profile\n\u003c/p\u003e\n"}]},{"ffmpeg":"gop_size","goRep":[{"name":"goav/avcodec.CodecContext::GopSize","doc":"\u003cp\u003e\nGopSize returns the number of pictures in a group of pictures, or 0 for intra_only.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: gop_size\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetGopSize","doc":"\u003cp\u003e\nSetGopSize sets the number of pictures in a group of pictures, or 0 for intra_only.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: gop_size\n\u003c/p\u003e\n"}]},{"ffmpeg":"av_codec_set_lowres","goRep":[{"name":"goav/avcodec.CodecContext::SetLowres","doc":"\u003cp\u003e\nSetLowres sets something undocumented.\nC-Function: av_codec_set_lowres\n\u003c/p\u003e\n"}]},{"ffmpeg":"avsubtitle_free","goRep":[{"name":"goav/avcodec.Subtitle::Free","doc":"\u003cp\u003e\nFree frees all allocated data of the Subtitle.\n\u003c/p\u003e\n\u003cp\u003e\nC-Function: avsubtitle_free\n\u003c/p\u003e\n"}]},{"ffmpeg":"coded_width","goRep":[{"name":"goav/avcodec.CodecContext::CodedWidth","doc":"\u003cp\u003e\nCodedWidth returns the bitstream width.\nIt may be different from the raw width. When the decoded frame is cropped before being output or lowres is enabled.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: coded_width\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetCodedWidth","doc":"\u003cp\u003e\nSetCodedWidth sets the bitstream width.\nIt may be different from the raw width. When the decoded frame is cropped before being output or lowres is enabled.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: coded_width\n\u003c/p\u003e\n"}]},{"ffmpeg":"av_codec_get_lowres","goRep":[{"name":"goav/avcodec.CodecContext::Lowres","doc":"\u003cp\u003e\nLowres returns something undocumented.\nC-Function: av_codec_get_lowres\n\u003c/p\u003e\n"}]},{"ffmpeg":"av_codec_set_seek_preroll","goRep":[{"name":"goav/avcodec.CodecContext::SetSeekPreroll","doc":"\u003cp\u003e\nSetSeekPreroll sets something undocumented.\nC-Function: av_codec_set_seek_preroll\n\u003c/p\u003e\n"}]},{"ffmpeg":"av_packet_unpack_dictionary","goRep":[{"name":"goav/avcodec.UnpackDictionary","doc":"\u003cp\u003e\nUnpackDictionary unpacks a dictionary from side_data.\n\u003c/p\u003e\n\u003cp\u003e\nC-Function: av_packet_unpack_dictionary\n\u003c/p\u003e\n"}]},{"ffmpeg":"avcodec_align_dimensions","goRep":[{"name":"goav/avcodec.CodecContext::AlignDimensions","doc":"\u003cp\u003e\nAlignDimensions modifies width and height values so that they will result in a memory buffer that is acceptable for the codec if you do not use any horizontal padding.\nMay only be used if a codec with AV_CODEC_CAP_DR1 has been opened.\nC-Function: avcodec_align_dimensions\n\u003c/p\u003e\n"}]},{"ffmpeg":"bit_rate","goRep":[{"name":"goav/avcodec.CodecContext::BitRate","doc":"\u003cp\u003e\nBitRate returns the average bit rate.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: bit_rate\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetBitRate","doc":"\u003cp\u003e\nSetBitRate sets the average bit rate.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: bit_rate\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecParameters::BitRate","doc":"\u003cp\u003e\nBitRate returns the average bitrate of the encoded data (in bits per second).\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: bit_rate\n\u003c/p\u003e\n"}]},{"ffmpeg":"dia_size","goRep":[{"name":"goav/avcodec.CodecContext::DiaSize","doc":"\u003cp\u003e\nDiaSize returns ME diamod size and shape.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: dia_size\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetDiaSize","doc":"\u003cp\u003e\nSetDiaSize sets ME diamod size and shape.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: dia_size\n\u003c/p\u003e\n"}]},{"ffmpeg":"av_parser_close","goRep":[{"name":"goav/avcodec.CodecParserContext::Close","doc":"\u003cp\u003e\nClose closes the CodecParserContext.\nC-Function: av_parser_close\n\u003c/p\u003e\n"}]},{"ffmpeg":"avcodec_align_dimensions2","goRep":[{"name":"goav/avcodec.CodecContext::AlignDimensions2","doc":"\u003cp\u003e\nAlignDimensions2 modifies width and height values so that they will result in a memory buffer that is acceptable for the codec if you also ensure that all line sizes are a multiple of the respective linesize_align[i].\nMay only be used if a codec with AV_CODEC_CAP_DR1 has been opened.\nC-Function: avcodec_align_dimensions2\n\u003c/p\u003e\n"}]},{"ffmpeg":"bit_rate_tolerance","goRep":[{"name":"goav/avcodec.CodecContext::BitRateTolerance","doc":"\u003cp\u003e\nBitRateTolerance returns the number of bits the bitstream is allowed to diverge from the reference.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: bit_rate_tolerance\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetBitRateTolerance","doc":"\u003cp\u003e\nSetBitRateTolerance sets the number of bits the bitstream is allowed to diverge from the reference.\nThe reference can be CBR (for CBR pass 1) or VBR (for VBR pass 2)\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: bit_rate_tolerance\n\u003c/p\u003e\n"}]},{"ffmpeg":"intra_dc_precision","goRep":[{"name":"goav/avcodec.CodecContext::IntraDcPrecision","doc":"\u003cp\u003e\nIntraDcPrecision returns the precision of the intra DC coefficient - 8.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: intra_dc_precision\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetIntraDcPrecision","doc":"\u003cp\u003e\nSetIntraDcPrecision sets the precision of the intra DC coefficient - 8.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: intra_dc_precision\n\u003c/p\u003e\n"}]},{"ffmpeg":"chroma_location","goRep":[{"name":"goav/avcodec.CodecParameters::ChromaLocation","doc":"\u003cp\u003e\nChromaLocation returns something undocumented...\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: chroma_location\n\u003c/p\u003e\n"}]},{"ffmpeg":"av_codec_get_chroma_intra_matrix","goRep":[{"name":"goav/avcodec.CodecContext::ChromaIntraMatrix","doc":"\u003cp\u003e\nChromaIntraMatrix returns something undocumented.\nC-Function: av_codec_get_chroma_intra_matrix\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetChromaIntraMatrix","doc":"\u003cp\u003e\nSetChromaIntraMatrix sets something undocumented.\nC-Function: av_codec_get_chroma_intra_matrix\n\u003c/p\u003e\n"}]},{"ffmpeg":"field_order","goRep":[{"name":"goav/avcodec.CodecParameters::FieldOrder","doc":"\u003cp\u003e\nFieldOrder returns the order of the fields in interlaced video.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: field_order\n\u003c/p\u003e\n"}]},{"ffmpeg":"format","goRep":[{"name":"goav/avcodec.CodecParameters::Format","doc":"\u003cp\u003e\nFormat returns the pixel/sample format of video/audio data.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: format\n\u003c/p\u003e\n"}]},{"ffmpeg":"video_delay","goRep":[{"name":"goav/avcodec.CodecParameters::VideoDelay","doc":"\u003cp\u003e\nVideoDelay returns the number of delayed frames.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: video_delay\n\u003c/p\u003e\n"}]},{"ffmpeg":"channels","goRep":[{"name":"goav/avcodec.CodecContext::Channels","doc":"\u003cp\u003e\nChannels returns the number of audio channels.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: channels\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecParameters::Channels","doc":"\u003cp\u003e\nChannels return the number of audio channels.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: channels\n\u003c/p\u003e\n"}]},{"ffmpeg":"avcodec_descriptor_next","goRep":[{"name":"goav/avcodec.RegisteredCodecDescriptors","doc":"\u003cp\u003e\nRegisteredCodecDescriptors returns a channel which can be used to iterate over the registered CodecDescriptor.\n\u003c/p\u003e\n\u003cp\u003e\nC-Function: avcodec_descriptor_next\n\u003c/p\u003e\n\u003cp\u003e\nUsage:\n\u003c/p\u003e\n\u003cpre\u003efor cc := range avcodec.RegisteredCodecDescriptors() {\n    // ...\n}\n\u003c/pre\u003e\n"}]},{"ffmpeg":"av_get_audio_frame_duration","goRep":[{"name":"goav/avcodec.CodecContext::AudioFrameDuration","doc":"\u003cp\u003e\nAudioFrameDuration returns audio frame duration, or 0 if not able to determine.\nC-Function: av_get_audio_frame_duration\n\u003c/p\u003e\n"}]},{"ffmpeg":"debug","goRep":[{"name":"goav/avcodec.CodecContext::Debug","doc":"\u003cp\u003e\nDebug returns... the documentation only says \u0026#34;debug\u0026#34;\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: debug\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetDebug","doc":"\u003cp\u003e\nSetDebug sets... the documentation only says \u0026#34;debug\u0026#34;\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: debug\n\u003c/p\u003e\n"}]},{"ffmpeg":"i_quant_offset","goRep":[{"name":"goav/avcodec.CodecContext::IQuantOffset","doc":"\u003cp\u003e\nIQuantOffset returns the qscale offset between P and I-frames.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: i_quant_offset\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetIQuantOffset","doc":"\u003cp\u003e\nSetIQuantOffset sets the qscale offset between P and I-frames.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: i_quant_offset\n\u003c/p\u003e\n"}]},{"ffmpeg":"avcodec_get_type","goRep":[{"name":"goav/avcodec.CodecId::Type","doc":"\u003cp\u003e\nType returns the type of the codec.\n\u003c/p\u003e\n\u003cp\u003e\nC-Function: avcodec_get_type\n\u003c/p\u003e\n"}]},{"ffmpeg":"av_codec_set_pkt_timebase","goRep":[{"name":"goav/avcodec.CodecContext::SetPktTimebase","doc":"\u003cp\u003e\nSetPktTimebase sets the packet timebase.\nC-Function: av_codec_set_pkt_timebase\n\u003c/p\u003e\n"}]},{"ffmpeg":"av_get_codec_tag_string","goRep":[{"name":"goav/avcodec.GetCodecTagString","doc":"\u003cp\u003e\nGetCodecTagString returns a string representing the codec tag codec_tag.\n\u003c/p\u003e\n\u003cp\u003e\nC-Function: av_get_codec_tag_string\n\u003c/p\u003e\n"}]},{"ffmpeg":"extradata_size","goRep":[{"name":"goav/avcodec.CodecContext::ExtradataSize","doc":"\u003cp\u003e\nExtradataSize returns the extradata size.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: extradata_size\n\u003c/p\u003e\n"}]},{"ffmpeg":"dct_algo","goRep":[{"name":"goav/avcodec.CodecContext::DctAlgo","doc":"\u003cp\u003e\nDctAlgo returns the DCT algorithm, see FF_DCT_*.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: dct_algo\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetDctAlgo","doc":"\u003cp\u003e\nSetDctAlgo sets the DCT algorithm, see FF_DCT_*.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: dct_algo\n\u003c/p\u003e\n"}]},{"ffmpeg":"idct_algo","goRep":[{"name":"goav/avcodec.CodecContext::IdctAlgo","doc":"\u003cp\u003e\nIdctAlgo returns the IDCT algorithm, see FF_IDCT_*.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: idct_algo\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetIdctAlgo","doc":"\u003cp\u003e\nSetIdctAlgo sets the IDCT algorithm, see FF_IDCT_*.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: idct_algo\n\u003c/p\u003e\n"}]},{"ffmpeg":"av_codec_set_codec_descriptor","goRep":[{"name":"goav/avcodec.CodecContext::SetCodecDescriptor","doc":"\u003cp\u003e\nSetCodecDescriptor sets the CodecDescriptor.\nC-Function: av_codec_set_codec_descriptor\n\u003c/p\u003e\n"}]},{"ffmpeg":"av_get_profile_name","goRep":[{"name":"goav/avcodec.Codec::ProfileName","doc":"\u003cp\u003e\nProfileName returns a name for the specified profile, if available.\n\u003c/p\u003e\n\u003cp\u003e\nC-Function: av_get_profile_name\n\u003c/p\u003e\n"}]},{"ffmpeg":"av_packet_pack_dictionary","goRep":[{"name":"goav/avcodec.Dictionary::Pack","doc":"\u003cp\u003e\nPack packs the dictionary for use in side_data.\n\u003c/p\u003e\n\u003cp\u003e\nC-Function: av_packet_pack_dictionary\n\u003c/p\u003e\n"}]},{"ffmpeg":"has_b_frames","goRep":[{"name":"goav/avcodec.CodecContext::HasBFrames","doc":"\u003cp\u003e\nHasBFrames returns the size of the reordering buffer in the decoder.\n\u003c/p\u003e\n\u003cp\u003e\nFor MPEG-2 it is 1 IPB or 0 low delay IP.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: has_b_frames\n\u003c/p\u003e\n"}]},{"ffmpeg":"avcodec_send_frame","goRep":[{"name":"goav/avcodec.CodecContext::SendFrame","doc":"\u003cp\u003e\nSendFrame sends a frame as input to the encoder.\nC-Function: avcodec_send_frame\n\u003c/p\u003e\n"}]},{"ffmpeg":"color_trc","goRep":[{"name":"goav/avcodec.CodecParameters::ColorTrc","doc":"\u003cp\u003e\nColorTrc returns something undocumented...\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: color_trc\n\u003c/p\u003e\n"}]},{"ffmpeg":"bits_per_coded_sample","goRep":[{"name":"goav/avcodec.CodecContext::BitsPerCodedSample","doc":"\u003cp\u003e\nBitsPerCodedSample returns the bits per sample/pixel from the demuxer (needed for huffyuv).\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: bits_per_coded_sample\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetBitsPerCodedSample","doc":"\u003cp\u003e\nSetBitsPerCodedSample set the bits per sample/pixel from the demuxer (needed for huffyuv).\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: bits_per_coded_sample\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecParameters::BitsPerCodedSample","doc":"\u003cp\u003e\nBitsPerCodedSample returns the number of bits per sample in the coded words.\n\u003c/p\u003e\n\u003cp\u003e\nThis is basically the bitrate per sample. It is mandatory for a bunch of formats to actually decode them. It\u0026#39;s the number of bits for one sample.\n\u003c/p\u003e\n\u003cp\u003e\nThis could be for example 4 for ADPCM For PCM formats this matches bits_per_raw_sample. Can be 0\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: bits_per_coded_sample\n\u003c/p\u003e\n"}]},{"ffmpeg":"dark_masking","goRep":[{"name":"goav/avcodec.CodecContext::DarkMasking","doc":"\u003cp\u003e\nDarkMasking returns the darkness masking (0 means \u0026#34;disabled\u0026#34;)\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: dark_masking\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetDarkMasking","doc":"\u003cp\u003e\nSetDarkMasking sets the darkness masking (0 means \u0026#34;disabled\u0026#34;)\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: dark_masking\n\u003c/p\u003e\n"}]},{"ffmpeg":"avcodec_default_get_format","goRep":[{"name":"goav/avcodec.CodecContext::DefaultGetFormat","doc":"\u003cp\u003e\nDefaultGetFormat is undocumented...\nC-Function: avcodec_default_get_format\n\u003c/p\u003e\n"}]},{"ffmpeg":"av_hwaccel_next","goRep":[{"name":"goav/avcodec.RegisteredHWAccels","doc":"\u003cp\u003e\nRegisteredHWAccels returns a channel which can be used to iterate over the registered HWAccel.\n\u003c/p\u003e\n\u003cp\u003e\nC-Function: av_hwaccel_next\n\u003c/p\u003e\n\u003cp\u003e\nUsage:\n\u003c/p\u003e\n\u003cpre\u003efor hwa := range avcodec.RegisteredHWAccels() {\n    // ...\n}\n\u003c/pre\u003e\n"}]},{"ffmpeg":"active_thread_type","goRep":[{"name":"goav/avcodec.CodecContext::ActiveThreadType","doc":"\u003cp\u003e\nActiveThreadType returns which multithreading methods are used by the codec.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: active_thread_type\n\u003c/p\u003e\n"}]},{"ffmpeg":"initial_padding","goRep":[{"name":"goav/avcodec.CodecParameters::InitialPadding","doc":"\u003cp\u003e\nInitialPadding returns the amount of padding (in samples) inserted by the encoder at the beginning of the audio. I.e. this number of leading decoded samples must be discarded by the caller to get the original audio without leading padding.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: initial_padding\n\u003c/p\u003e\n"}]},{"ffmpeg":"avcodec_descriptor_get","goRep":[{"name":"goav/avcodec.CodecId::Descriptor","doc":"\u003cp\u003e\nDescriptor returns the CodecDescriptor of the codec.\n\u003c/p\u003e\n\u003cp\u003e\nC-Function: avcodec_descriptor_get\n\u003c/p\u003e\n"}]},{"ffmpeg":"av_get_exact_bits_per_sample","goRep":[{"name":"goav/avcodec.CodecId::ExactBitsPerSample","doc":"\u003cp\u003e\nExactBitsPerSample returns codec bits per sample.\n\u003c/p\u003e\n\u003cp\u003e\nC-Function: av_get_exact_bits_per_sample\n\u003c/p\u003e\n"}]},{"ffmpeg":"color_range","goRep":[{"name":"goav/avcodec.CodecParameters::ColorRange","doc":"\u003cp\u003e\nColorRange returns additional colorspace characteristics.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: color_range\n\u003c/p\u003e\n"}]},{"ffmpeg":"trailing_padding","goRep":[{"name":"goav/avcodec.CodecParameters::TrailingPadding","doc":"\u003cp\u003e\nTrailingPadding returns the amount of padding (in samples) appended by the encoder to the end of the audio. I.e. this number of decoded samples must be discarded by the caller from the end of the stream to get the original audio without any trailing padding.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: trailing_padding\n\u003c/p\u003e\n"}]},{"ffmpeg":"avcodec_license","goRep":[{"name":"goav/avcodec.License","doc":"\u003cp\u003e\nLicense returns the libavcodec license.\n\u003c/p\u003e\n\u003cp\u003e\nC-Function: avcodec_license\n\u003c/p\u003e\n"}]},{"ffmpeg":"av_parser_parse2","goRep":[{"name":"goav/avcodec.CodecContext::Parse","doc":"\u003cp\u003e\nParse is not yet completely implemented.\nC-Function: av_parser_parse2\nTODO\n\u003c/p\u003e\n"}]},{"ffmpeg":"av_get_bits_per_sample","goRep":[{"name":"goav/avcodec.CodecId::BitsPerSample","doc":"\u003cp\u003e\nBitsPerSample returns codec bits per sample.\n\u003c/p\u003e\n\u003cp\u003e\nC-Function: av_get_bits_per_sample\n\u003c/p\u003e\n"}]},{"ffmpeg":"cutoff","goRep":[{"name":"goav/avcodec.CodecContext::Cutoff","doc":"\u003cp\u003e\nCutoff returns the audio cutoff bandwidth (0 means \u0026#34;automatic\u0026#34;)\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: cutoff\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetCutoff","doc":"\u003cp\u003e\nSetCutoff sets the audio cutoff bandwidth (0 means \u0026#34;automatic\u0026#34;)\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: cutoff\n\u003c/p\u003e\n"}]},{"ffmpeg":"coded_height","goRep":[{"name":"goav/avcodec.CodecContext::CodedHeight","doc":"\u003cp\u003e\nCodedHeight returns the bitstream height.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: coded_height\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetCodedHeight","doc":"\u003cp\u003e\nSetCodedHeight sets the bitstream height.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: coded_height\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetHeight","doc":"\u003cp\u003e\nSetHeight sets the raw image height.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: coded_height\n\u003c/p\u003e\n"}]},{"ffmpeg":"compression_level","goRep":[{"name":"goav/avcodec.CodecContext::CompressionLevel","doc":"\u003cp\u003e\nCompressionLevel returns the compression level.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: compression_level\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetCompressionLevel","doc":"\u003cp\u003e\nSetCompressionLevel sets the compression level.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: compression_level\n\u003c/p\u003e\n"}]},{"ffmpeg":"debug_mv","goRep":[{"name":"goav/avcodec.CodecContext::DebugMv","doc":"\u003cp\u003e\nDebugMv returns... the documentation only says \u0026#34;debug\u0026#34;\nCode outside libavcodec should access this field using AVOptions.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: debug_mv\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetDebugMv","doc":"\u003cp\u003e\nSetDebugMv sets... the documentation only says \u0026#34;debug\u0026#34;\nCode outside libavcodec should access this field using AVOptions.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: debug_mv\n\u003c/p\u003e\n"}]},{"ffmpeg":"avcodec_receive_frame","goRep":[{"name":"goav/avcodec.CodecContext::ReceiveFrame","doc":"\u003cp\u003e\nReceiveFrame receives a frame as output from the decoder.\nC-Function: avcodec_receive_frame\n\u003c/p\u003e\n"}]},{"ffmpeg":"avcodec_configuration","goRep":[{"name":"goav/avcodec.Configuration","doc":"\u003cp\u003e\nConfiguration returns the libavcodec build-time configuration.\n\u003c/p\u003e\n\u003cp\u003e\nC-Function: avcodec_configuration\n\u003c/p\u003e\n"}]},{"ffmpeg":"bidir_refine","goRep":[{"name":"goav/avcodec.CodecContext::BidirRefine","doc":"\u003cp\u003e\nBidirRefine returns something undocumented...\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: bidir_refine\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetBidirRefine","doc":"\u003cp\u003e\nSetBidirRefine sets something undocumented...\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: bidir_refine\n\u003c/p\u003e\n"}]},{"ffmpeg":"bits_per_raw_sample","goRep":[{"name":"goav/avcodec.CodecContext::BitsPerRawSample","doc":"\u003cp\u003e\nBitsPerRawSample returns the bits per sample/pixel of internal libavcodec pixel/sample format.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: bits_per_raw_sample\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetBitsPerRawSample","doc":"\u003cp\u003e\nSetBitsPerRawSample sets the bits per sample/pixel of internal libavcodec pixel/sample format.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: bits_per_raw_sample\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecParameters::BitsPerRawSample","doc":"\u003cp\u003e\nBitsPerRawSample returns the number of valid bits in each output sample.\n\u003c/p\u003e\n\u003cp\u003e\nIf the sample format has more bits, the least significant bits are additional padding bits, which are always 0. Use right shifts to reduce the sample to its actual size. For example, audio formats with 24 bit samples will have bits_per_raw_sample set to 24, and format set to AV_SAMPLE_FMT_S32. To get the original sample use \u0026#34;(int32_t)sample \u0026gt;\u0026gt; 8\u0026#34;.\u0026#34;\n\u003c/p\u003e\n\u003ch3 id=\"hdr-For_ADPCM_this_might_be_12_or_16_or_similar_Can_be_0\"\u003eFor ADPCM this might be 12 or 16 or similar Can be 0\u003c/h3\u003e\n\u003cp\u003e\nC-Attribute: bits_per_raw_sample\n\u003c/p\u003e\n"}]},{"ffmpeg":"avcodec_send_packet","goRep":[{"name":"goav/avcodec.CodecContext::SendPacket","doc":"\u003cp\u003e\nSendPacket sends a packet as input to the decoder.\nC-Function: avcodec_send_packet\n\u003c/p\u003e\n"}]},{"ffmpeg":"error_concealment","goRep":[{"name":"goav/avcodec.CodecContext::ErrorConcealment","doc":"\u003cp\u003e\nErrorConcealment returns error concealment flags.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: error_concealment\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetErrorConcealment","doc":"\u003cp\u003e\nSetErrorConcealment sets error concealment flags.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: error_concealment\n\u003c/p\u003e\n"}]},{"ffmpeg":"av_parser_change","goRep":[{"name":"goav/avcodec.CodecContext::ParserChange","doc":"\u003cp\u003e\nParserChange is not yet completely implemented.\nC-Function: av_parser_change\nTODO\n\u003c/p\u003e\n"}]},{"ffmpeg":"seek_preroll","goRep":[{"name":"goav/avcodec.CodecParameters::SeekPreroll","doc":"\u003cp\u003e\nSeekPreroll returns the number of sample to skip after a discontinuity.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: seek_preroll\n\u003c/p\u003e\n"}]},{"ffmpeg":"avcodec_flush_buffers","goRep":[{"name":"goav/avcodec.CodecContext::FlushBuffers","doc":"\u003cp\u003e\nFlushBuffers resets the internal decoder state / flush internal buffers.\nShould be called e.g. when seeking or when switching to a different stream.\nC-Function: avcodec_flush_buffers\n\u003c/p\u003e\n"}]},{"ffmpeg":"avcodec_free_context","goRep":[{"name":"goav/avcodec.CodecContext::Free","doc":"\u003cp\u003e\nFree frees the codec context and everything associated with it.\nC-Function: avcodec_free_context\n\u003c/p\u003e\n"}]},{"ffmpeg":"b_quant_factor","goRep":[{"name":"goav/avcodec.CodecContext::BQuantFactor","doc":"\u003cp\u003e\nBQuantFactor returns the qscale factor between IP and B-frames.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: b_quant_factor\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetBQuantFactor","doc":"\u003cp\u003e\nSetBQuantFactor sets the qscale factor between IP and B-frames.\nIf \u0026gt; 0 then the last P-frame quantizer will be used (q = lastp_q*factor+offset).\nIf \u0026lt; 0 then normal ratecontrol will be done (q = -normal_q*factor+offset)\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: b_quant_factor\n\u003c/p\u003e\n"}]},{"ffmpeg":"avcodec_decode_subtitle2","goRep":[{"name":"goav/avcodec.CodecContext::DecodeSubtitle","doc":"\u003cp\u003e\nDecodeSubtitle decodes a subtitle message.\n\u003c/p\u003e\n\u003cp\u003e\nReturn a negative value on error, otherwise return the number of bytes used. If no subtitle could be decompressed, got_sub_ptr is zero. Otherwise, the subtitle is stored in *sub. Note that AV_CODEC_CAP_DR1 is not available for subtitle codecs. This is for simplicity, because the performance difference is expect to be negligible and reusing a get_buffer written for video codecs would probably perform badly due to a potentially very different allocation pattern.\n\u003c/p\u003e\n\u003cp\u003e\nSome decoders (those marked with CODEC_CAP_DELAY) have a delay between input and output. This means that for some packets they will not immediately produce decoded output and need to be flushed at the end of decoding to get all the decoded data. Flushing is done by calling this function with packets with avpkt-\u0026gt;data set to NULL and avpkt-\u0026gt;size set to 0 until it stops returning subtitles. It is safe to flush even those decoders that are not marked with CODEC_CAP_DELAY, then no subtitles will be returned.\nC-Function: avcodec_decode_subtitle2\n\u003c/p\u003e\n"}]},{"ffmpeg":"frame_size","goRep":[{"name":"goav/avcodec.CodecContext::FrameSize","doc":"\u003cp\u003e\nFrameSize returns the number of samples per channel in an audio frame.\n\u003c/p\u003e\n\u003cp\u003e\nEncoding: Set by libavcodec in avcodec_open2(). Each submitted frame except the last must contain exactly frame_size samples per channel. May be 0 when the codec has AV_CODEC_CAP_VARIABLE_FRAME_SIZE set, then the frame size is not restricted.\nDecoding: May be set by some decoders to indicate constant frame size.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: frame_size\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecParameters::FrameSize","doc":"\u003cp\u003e\nFrameSize returns the audio frame size, if known.\nRequired by some formats to be static.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: frame_size\n\u003c/p\u003e\n"}]},{"ffmpeg":"av_codec_get_pkt_timebase","goRep":[{"name":"goav/avcodec.CodecContext::PktTimebase","doc":"\u003cp\u003e\nPktTimebase returns the packet timebase.\nC-Function: av_codec_get_pkt_timebase\n\u003c/p\u003e\n"}]},{"ffmpeg":"color_space","goRep":[{"name":"goav/avcodec.CodecParameters::ColorSpace","doc":"\u003cp\u003e\nColorSpace returns something undocumented...\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: color_space\n\u003c/p\u003e\n"}]},{"ffmpeg":"avcodec_register_all","goRep":[{"name":"goav/avcodec.RegisterAll","doc":"\u003cp\u003e\nRegisterAll registers all the codecs, parsers and bitstream filters which were enabled at configuration time.\n\u003c/p\u003e\n\u003cp\u003e\nC-Function: avcodec_register_all\n\u003c/p\u003e\n"}]},{"ffmpeg":"avcodec_version","goRep":[{"name":"goav/avcodec.Version","doc":"\u003cp\u003e\nVersion returns the LIBAvCODEC_VERSION_INT constant.\n\u003c/p\u003e\n\u003cp\u003e\nC-Function: avcodec_version\n\u003c/p\u003e\n"}]},{"ffmpeg":"avcodec_enum_to_chroma_pos","goRep":[{"name":"goav/avcodec.ChromaLocation::ToChromaPos","doc":"\u003cp\u003e\nToChromaPos converts the ChromaLocation to swscale x/y chroma position.\n\u003c/p\u003e\n\u003cp\u003e\nC-Function: avcodec_enum_to_chroma_pos\n\u003c/p\u003e\n"}]},{"ffmpeg":"channel_layout","goRep":[{"name":"goav/avcodec.CodecParameters::ChannelLayout","doc":"\u003cp\u003e\nChannelLayout returns the channel layout bitmask.\nMay be 0 if the channel layout is unknown or unspecified, otherwise the number of bits set bmust be equal to the channels field.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: channel_layout\n\u003c/p\u003e\n"}]},{"ffmpeg":"av_parser_next","goRep":[{"name":"goav/avcodec.RegisteredCodecParsers","doc":"\u003cp\u003e\nRegisteredCodecParsers returns a channel which can be used to iterate over the registered CodecParser.\nC-Function: av_parser_next\n\u003c/p\u003e\n\u003cp\u003e\nUsage:\n\u003c/p\u003e\n\u003cpre\u003efor cc := range avcodec.RegisteredCodecDescriptors() {\n    // ...\n}\n\u003c/pre\u003e\n"}]},{"ffmpeg":"av_codec_get_codec_descriptor","goRep":[{"name":"goav/avcodec.CodecContext::CodecDescriptor","doc":"\u003cp\u003e\nCodecDescriptor returns the CodecDescriptor.\nC-Function: av_codec_get_codec_descriptor\n\u003c/p\u003e\n"}]},{"ffmpeg":"av_fast_padded_mallocz","goRep":[{"name":"goav/avcodec.FastPaddedMallocz","doc":"\u003cp\u003e\nFastPaddedMallocz allocates a buffer, reusing the given one if large enough and initializes the data with 0.\nThe buffer has additional FF_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0.\n\u003c/p\u003e\n\u003cp\u003e\nC-Function: av_fast_padded_mallocz\n\u003c/p\u003e\n"}]},{"ffmpeg":"codec_id","goRep":[{"name":"goav/avcodec.CodecParameters::CodecID","doc":"\u003cp\u003e\nCodecID returns the id of the codec.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: codec_id\n\u003c/p\u003e\n"}]},{"ffmpeg":"level","goRep":[{"name":"goav/avcodec.CodecParameters::Level","doc":"\u003cp\u003e\nLevel returns something undocumented...\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: level\n\u003c/p\u003e\n"}]},{"ffmpeg":"frame_number","goRep":[{"name":"goav/avcodec.CodecContext::FrameNumber","doc":"\u003cp\u003e\nFrameNumber returns the Frame counter, set by libavcodec.\n\u003c/p\u003e\n\u003cp\u003e\nDecoding: Total number of frames returned from the decoder so far.\nEncoding: Total number of frames passed to the encoder so far.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: frame_number\n\u003c/p\u003e\n"}]},{"ffmpeg":"i_quant_factor","goRep":[{"name":"goav/avcodec.CodecContext::IQuantFactor","doc":"\u003cp\u003e\nIQuantFactor returns the qscale factor between P- and I-frames.\nIf \u0026gt; 0 then the last P-frame quantizer will be used (q = lastp_q * factor + offset).\nIf \u0026lt; 0 then normal ratecontrol will be done (q = -normal_q * factor + offset).\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: i_quant_factor\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetIQuantFactor","doc":"\u003cp\u003e\nSetIQuantFactor sets the qscale factor between P- and I-frames.\nIf \u0026gt; 0 then the last P-frame quantizer will be used (q = lastp_q * factor + offset).\nIf \u0026lt; 0 then normal ratecontrol will be done (q = -normal_q * factor + offset).\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: i_quant_factor\n\u003c/p\u003e\n"}]},{"ffmpeg":"codec_tag","goRep":[{"name":"goav/avcodec.CodecParameters::CodecTag","doc":"\u003cp\u003e\nCodecTag returns additional information about the codec (corrensponds to the AVI FOURCC).\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: codec_tag\n\u003c/p\u003e\n"}]},{"ffmpeg":"delay","goRep":[{"name":"goav/avcodec.CodecContext::Delay","doc":"\u003cp\u003e\nDelay returns the codec delay.\n\u003c/p\u003e\n\u003cp\u003e\nEncoding: Number of frames delay there will be from the encoder input to the decoder output. (we assume the decoder matches the spec) Decoding: Number of frames delay in addition to what a standard decoder as specified in the spec would produce.\n\u003c/p\u003e\n\u003cp\u003e\nVideo: Number of frames the decoded output will be delayed relative to the encoded input.\n\u003c/p\u003e\n\u003cp\u003e\nAudio: For encoding, this field is unused (see initial_padding).\n\u003c/p\u003e\n\u003cp\u003e\nFor decoding, this is the number of samples the decoder needs to output before the decoder\u0026#39;s output is valid. When seeking, you should start decoding this many samples prior to your desired seek point.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: delay\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetDelay","doc":"\u003cp\u003e\nSetDelay sets the codec delay.\n\u003c/p\u003e\n\u003cp\u003e\nEncoding: Number of frames delay there will be from the encoder input to the decoder output. (we assume the decoder matches the spec) Decoding: Number of frames delay in addition to what a standard decoder as specified in the spec would produce.\n\u003c/p\u003e\n\u003cp\u003e\nVideo: Number of frames the decoded output will be delayed relative to the encoded input.\n\u003c/p\u003e\n\u003cp\u003e\nAudio: For encoding, this field is unused (see initial_padding).\n\u003c/p\u003e\n\u003cp\u003e\nFor decoding, this is the number of samples the decoder needs to output before the decoder\u0026#39;s output is valid. When seeking, you should start decoding this many samples prior to your desired seek point.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: delay\n\u003c/p\u003e\n"}]},{"ffmpeg":"ildct_cmp","goRep":[{"name":"goav/avcodec.CodecContext::IldctCmp","doc":"\u003cp\u003e\nIldctCmp returns the interlaced DCT comparison function.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: ildct_cmp\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetIldctCmp","doc":"\u003cp\u003e\nSetIldctCmp sets the interlaced DCT comparison function.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: ildct_cmp\n\u003c/p\u003e\n"}]},{"ffmpeg":"av_codec_get_seek_preroll","goRep":[{"name":"goav/avcodec.CodecContext::SeekPreroll","doc":"\u003cp\u003e\nSeekPreroll returns something undocumented.\nC-Function: av_codec_get_seek_preroll\n\u003c/p\u003e\n"}]},{"ffmpeg":"block_align","goRep":[{"name":"goav/avcodec.CodecContext::BlockAlign","doc":"\u003cp\u003e\nBlockAlign returns the number of bytes per packet if constant and known or 0.\nUsed by some WAV based audio codecs.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: block_align\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecParameters::BlockAlign","doc":"\u003cp\u003e\nBlockAlign returns the number of bytes per coded audio frame, required by some formats.\n\u003c/p\u003e\n\u003cp\u003e\nCorresponds to nBlockAlign in WAVEFORMATEX.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: block_align\n\u003c/p\u003e\n"}]},{"ffmpeg":"flags2","goRep":[{"name":"goav/avcodec.CodecContext::Flags2","doc":"\u003cp\u003e\nFlags2 returns the flags AV_CODEC_FLAG2_*.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: flags2\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetFlags2","doc":"\u003cp\u003e\nSetFlags2 sets the flags AV_CODEC_FLAG2_*.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: flags2\n\u003c/p\u003e\n"}]},{"ffmpeg":"avcodec_close","goRep":[{"name":"goav/avcodec.CodecContext::Close","doc":"\u003cp\u003e\nClose closes a given Context and free all the data associated with it (but not the Context itself).\nC-Function: avcodec_close\n\u003c/p\u003e\n"}]},{"ffmpeg":"codec_type","goRep":[{"name":"goav/avcodec.CodecParameters::CodecType","doc":"\u003cp\u003e\nCodecType returns the general type of the encoded data.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: codec_type\n\u003c/p\u003e\n"}]},{"ffmpeg":"avcodec_register","goRep":[{"name":"goav/avcodec.RegisterCodec","doc":"\u003cp\u003e\nRegisterCodec registers the codec and initializes libavcodec.\n\u003c/p\u003e\n\u003cp\u003e\nC-Function: avcodec_register\n\u003c/p\u003e\n"}]},{"ffmpeg":"av_codec_next","goRep":[{"name":"goav/avcodec.RegisteredCodecs","doc":"\u003cp\u003e\nRegisteredCodecs returns a channel which can be used to iterate over the registered codecs.\n\u003c/p\u003e\n\u003cp\u003e\nC-Function: av_codec_next\n\u003c/p\u003e\n\u003cp\u003e\nUsage:\n\u003c/p\u003e\n\u003cpre\u003efor codec := range avcodec.RegisteredCodecs() {\n    // ...\n}\n\u003c/pre\u003e\n"}]},{"ffmpeg":"av_get_pcm_codec","goRep":[{"name":"goav/avcodec.SampleFormat::PcmCodec","doc":"\u003cp\u003e\nPcmCodec returns the PCM codec associated with the sample format.\n\u003c/p\u003e\n\u003cp\u003e\nC-Function: av_get_pcm_codec\n\u003c/p\u003e\n"}]},{"ffmpeg":"avcodec_is_open","goRep":[{"name":"goav/avcodec.CodecContext::IsOpen","doc":"\u003cp\u003e\nIsOpen returns true iff the CodecContext was opened and not yet closed.\nC-Function: avcodec_is_open\n\u003c/p\u003e\n"}]},{"ffmpeg":"color_primaries","goRep":[{"name":"goav/avcodec.CodecParameters::ColorPrimaries","doc":"\u003cp\u003e\nColorPrimaries returns something undocumented...\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: color_primaries\n\u003c/p\u003e\n"}]},{"ffmpeg":"sample_aspect_ratio","goRep":[{"name":"goav/avcodec.CodecParameters::SampleAspectRatio","doc":"\u003cp\u003e\nSampleAspectRatio returns the aspect ratio (width / height) which a single pixel should have when displayed.\n\u003c/p\u003e\n\u003cp\u003e\nWhen the aspect ratio is unknown / undefined, the numerator should be set to 0 (the denominator may have any value).\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: sample_aspect_ratio\n\u003c/p\u003e\n"}]},{"ffmpeg":"b_quant_offset","goRep":[{"name":"goav/avcodec.CodecContext::BQuantOffset","doc":"\u003cp\u003e\nBQuantOffset return the qscale offset between IP and B-frames.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: b_quant_offset\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetBQuantOffset","doc":"\u003cp\u003e\nSetBQuantOffset return the qscale offset between IP and B-frames.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: b_quant_offset\n\u003c/p\u003e\n"}]},{"ffmpeg":"err_recognition","goRep":[{"name":"goav/avcodec.CodecContext::ErrRecognition","doc":"\u003cp\u003e\nErrRecognition returns the error recognition.\nIt may misdetect some more or less valid parts as errors.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: err_recognition\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecContext::SetErrRecognition","doc":"\u003cp\u003e\nSetErrRecognition sets the error recognition.\nIt may misdetect some more or less valid parts as errors.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: err_recognition\n\u003c/p\u003e\n"}]},{"ffmpeg":"av_codec_get_max_lowres","goRep":[{"name":"goav/avcodec.Codec::MaxLowres","doc":"\u003cp\u003e\nMaxLowres returns the maximum lowres supported by the decoder.\n\u003c/p\u003e\n\u003cp\u003e\nC-Function: av_codec_get_max_lowres\n\u003c/p\u003e\n"}]},{"ffmpeg":"avcodec_get_name","goRep":[{"name":"goav/avcodec.CodecId::Name","doc":"\u003cp\u003e\nName returns the name of the codec.\n\u003c/p\u003e\n\u003cp\u003e\nC-Function: avcodec_get_name\n\u003c/p\u003e\n"}]},{"ffmpeg":"sample_rate","goRep":[{"name":"goav/avcodec.CodecParameters::SampleRate","doc":"\u003cp\u003e\nSampleRate returns the number of audio samples per second.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: sample_rate\n\u003c/p\u003e\n"}]},{"ffmpeg":"height","goRep":[{"name":"goav/avcodec.CodecContext::Height","doc":"\u003cp\u003e\nHeight returns the raw image height.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: height\n\u003c/p\u003e\n"},{"name":"goav/avcodec.CodecParameters::Height","doc":"\u003cp\u003e\nHeight returns the height of the video frame in pixels.\n\u003c/p\u003e\n\u003cp\u003e\nC-Attribute: height\n\u003c/p\u003e\n"}]}];
